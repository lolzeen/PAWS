#ifndef PAWS_LIB_VISUCONTROL_H
#define PAWS_LIB_VISUCONTROL_H

#endif // PAWS_LIB_VISUCONTROL_H
/*


#include <Arduino.h>
#include <U8g2lib.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif


/*
  U8g2lib Example Overview:
    Frame Buffer Examples: clearBuffer/sendBuffer. Fast, but may not work with all Arduino boards because of RAM consumption
    Page Buffer Examples: firstPage/nextPage. Less RAM usage, should work with all Arduino boards.
    U8x8 Text Only Example: No RAM usage, direct communication with display controller. No graphics, 8x8 Text only.
    
  This is a page buffer example.    
*/

// Please UNCOMMENT one of the contructor lines below
// U8g2 Contructor List (Picture Loop Page Buffer)
// The complete list is available here: https://github.com/olikraus/u8g2/wiki/u8g2setupcpp
// Please update the pin numbers according to your setup. Use U8X8_PIN_NONE if the reset pin is not connected

/*
U8G2_ST7920_128X64_1_SW_SPI u8g2(U8G2_R0, 18, 22, 23, U8X8_PIN_NONE);


void u8g2_prepare(void) {
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);
}

void u8g2_box_title(uint8_t a) {
  u8g2.drawStr( 10+a*2, 5, "U8g2");
  u8g2.drawStr( 10, 20, "GraphicsTest");
  
  u8g2.drawFrame(0,0,u8g2.getDisplayWidth(),u8g2.getDisplayHeight() );
}

void u8g2_box_frame(uint8_t a) {
  u8g2.drawStr( 0, 0, "drawBox");
  u8g2.drawBox(5,10,20,10);
  u8g2.drawBox(10+a,15,30,7);
  u8g2.drawStr( 0, 30, "drawFrame");
  u8g2.drawFrame(5,10+30,20,10);
  u8g2.drawFrame(10+a,15+30,30,7);
}

void u8g2_disc_circle(uint8_t a) {
  u8g2.drawStr( 0, 0, "drawDisc");
  u8g2.drawDisc(10,18,9);
  u8g2.drawDisc(24+a,16,7);
  u8g2.drawStr( 0, 30, "drawCircle");
  u8g2.drawCircle(10,18+30,9);
  u8g2.drawCircle(24+a,16+30,7);
}

void u8g2_r_frame(uint8_t a) {
  u8g2.drawStr( 0, 0, "drawRFrame/Box");
  u8g2.drawRFrame(5, 10,40,30, a+1);
  u8g2.drawRBox(50, 10,25,40, a+1);
}

void u8g2_string(uint8_t a) {
  u8g2.setFontDirection(0);
  u8g2.drawStr(30+a,31, " 0");
  u8g2.setFontDirection(1);
  u8g2.drawStr(30,31+a, " 90");
  u8g2.setFontDirection(2);
  u8g2.drawStr(30-a,31, " 180");
  u8g2.setFontDirection(3);
  u8g2.drawStr(30,31-a, " 270");
}

void u8g2_line(uint8_t a) {
  u8g2.drawStr( 0, 0, "drawLine");
  u8g2.drawLine(7+a, 10, 40, 55);
  u8g2.drawLine(7+a*2, 10, 60, 55);
  u8g2.drawLine(7+a*3, 10, 80, 55);
  u8g2.drawLine(7+a*4, 10, 100, 55);
}

void u8g2_triangle(uint8_t a) {
  uint16_t offset = a;
  u8g2.drawStr( 0, 0, "drawTriangle");
  u8g2.drawTriangle(14,7, 45,30, 10,40);
  u8g2.drawTriangle(14+offset,7-offset, 45+offset,30-offset, 57+offset,10-offset);
  u8g2.drawTriangle(57+offset*2,10, 45+offset*2,30, 86+offset*2,53);
  u8g2.drawTriangle(10+offset,40+offset, 45+offset,30+offset, 86+offset,53+offset);
}

void u8g2_ascii_1() {
  char s[2] = " ";
  uint8_t x, y;
  u8g2.drawStr( 0, 0, "ASCII page 1");
  for( y = 0; y < 6; y++ ) {
    for( x = 0; x < 16; x++ ) {
      s[0] = y*16 + x + 32;
      u8g2.drawStr(x*7, y*10+10, s);
    }
  }
}

void u8g2_ascii_2() {
  char s[2] = " ";
  uint8_t x, y;
  u8g2.drawStr( 0, 0, "ASCII page 2");
  for( y = 0; y < 6; y++ ) {
    for( x = 0; x < 16; x++ ) {
      s[0] = y*16 + x + 160;
      u8g2.drawStr(x*7, y*10+10, s);
    }
  }
}

void u8g2_extra_page(uint8_t a)
{
  u8g2.drawStr( 0, 0, "Unicode");
  u8g2.setFont(u8g2_font_unifont_t_symbols);
  u8g2.setFontPosTop();
  u8g2.drawUTF8(0, 24, "☀ ☁");
  switch(a) {
    case 0:
    case 1:
    case 2:
    case 3:
      u8g2.drawUTF8(a*3, 36, "☂");
      break;
    case 4:
    case 5:
    case 6:
    case 7:
      u8g2.drawUTF8(a*3, 36, "☔");
      break;
  }
}

void u8g2_xor(uint8_t a) {
  uint8_t i;
  u8g2.drawStr( 0, 0, "XOR");
  u8g2.setFontMode(1);
  u8g2.setDrawColor(2);
  for( i = 0; i < 5; i++)
  {
    u8g2.drawBox(10+i*16, 18 + (i&1)*4, 21,31);
  }
  u8g2.drawStr( 5+a, 19, "XOR XOR XOR XOR");
  u8g2.setDrawColor(0);
  u8g2.drawStr( 5+a, 29, "CLR CLR CLR CLR");
  u8g2.setDrawColor(1);
  u8g2.drawStr( 5+a, 39, "SET SET SET SET");
  u8g2.setFontMode(0);
    
}

#define cross_width 24
#define cross_height 24
static const unsigned char cross_bits[] U8X8_PROGMEM  = {
  0x00, 0x18, 0x00, 0x00, 0x24, 0x00, 0x00, 0x24, 0x00, 0x00, 0x42, 0x00, 
  0x00, 0x42, 0x00, 0x00, 0x42, 0x00, 0x00, 0x81, 0x00, 0x00, 0x81, 0x00, 
  0xC0, 0x00, 0x03, 0x38, 0x3C, 0x1C, 0x06, 0x42, 0x60, 0x01, 0x42, 0x80, 
  0x01, 0x42, 0x80, 0x06, 0x42, 0x60, 0x38, 0x3C, 0x1C, 0xC0, 0x00, 0x03, 
  0x00, 0x81, 0x00, 0x00, 0x81, 0x00, 0x00, 0x42, 0x00, 0x00, 0x42, 0x00, 
  0x00, 0x42, 0x00, 0x00, 0x24, 0x00, 0x00, 0x24, 0x00, 0x00, 0x18, 0x00, };

#define cross_fill_width 24
#define cross_fill_height 24
static const unsigned char cross_fill_bits[] U8X8_PROGMEM  = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x64, 0x00, 0x26, 
  0x84, 0x00, 0x21, 0x08, 0x81, 0x10, 0x08, 0x42, 0x10, 0x10, 0x3C, 0x08, 
  0x20, 0x00, 0x04, 0x40, 0x00, 0x02, 0x80, 0x00, 0x01, 0x80, 0x18, 0x01, 
  0x80, 0x18, 0x01, 0x80, 0x00, 0x01, 0x40, 0x00, 0x02, 0x20, 0x00, 0x04, 
  0x10, 0x3C, 0x08, 0x08, 0x42, 0x10, 0x08, 0x81, 0x10, 0x84, 0x00, 0x21, 
  0x64, 0x00, 0x26, 0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };

#define cross_block_width 14
#define cross_block_height 14
static const unsigned char cross_block_bits[] U8X8_PROGMEM  = {
  0xFF, 0x3F, 0x01, 0x20, 0x01, 0x20, 0x01, 0x20, 0x01, 0x20, 0x01, 0x20, 
  0xC1, 0x20, 0xC1, 0x20, 0x01, 0x20, 0x01, 0x20, 0x01, 0x20, 0x01, 0x20, 
  0x01, 0x20, 0xFF, 0x3F, };

void u8g2_bitmap_overlay(uint8_t a) {
  uint8_t frame_size = 28;

  u8g2.drawStr(0, 0, "Bitmap overlay");

  u8g2.drawStr(0, frame_size + 12, "Solid / transparent");
  u8g2.setBitmapMode(false); //solid
  u8g2.drawFrame(0, 10, frame_size, frame_size);
  u8g2.drawXBMP(2, 12, cross_width, cross_height, cross_bits);
  if(a & 4)
    u8g2.drawXBMP(7, 17, cross_block_width, cross_block_height, cross_block_bits);

  u8g2.setBitmapMode(true); // transparent
  u8g2.drawFrame(frame_size + 5, 10, frame_size, frame_size);
  u8g2.drawXBMP(frame_size + 7, 12, cross_width, cross_height, cross_bits);
  if(a & 4)
    u8g2.drawXBMP(frame_size + 12, 17, cross_block_width, cross_block_height, cross_block_bits);
}

void u8g2_bitmap_modes(uint8_t transparent) {
  const uint8_t frame_size = 24;

  u8g2.drawBox(0, frame_size * 0.5, frame_size * 5, frame_size);
  u8g2.drawStr(frame_size * 0.5, 50, "Black");
  u8g2.drawStr(frame_size * 2, 50, "White");
  u8g2.drawStr(frame_size * 3.5, 50, "XOR");
  
  if(!transparent) {
    u8g2.setBitmapMode(false); //solid
    u8g2.drawStr(0, 0, "Solid bitmap");
  } else {
    u8g2.setBitmapMode(true); //transparent
    u8g2.drawStr(0, 0, "Transparent bitmap");
  }
  u8g2.setDrawColor(0);// Black
  u8g2.drawXBMP(frame_size * 0.5, 24, cross_width, cross_height, cross_bits);
  u8g2.setDrawColor(1); // White
  u8g2.drawXBMP(frame_size * 2, 24, cross_width, cross_height, cross_bits);
  u8g2.setDrawColor(2); // XOR
  u8g2.drawXBMP(frame_size * 3.5, 24, cross_width, cross_height, cross_bits);
}

static const unsigned char hello_screen[] = {
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xf3,0xff,0xff,0xdf,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xe3,0xff,0xff,0x0f,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xc3,0xff,0xff,0x0f,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0x81,0xff,0xfe,0x0f,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0x80,0xff,0xfc,0x07,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0x00,0xff,0xf8,0x07,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0x00,0xff,0xe0,0x03,0xff,0xff,0xdc,
    0xff,0xff,0xff,0xff,0xff,0xfc,0x01,0xff,0xe0,0x03,0xff,0xff,0x9c,
    0xff,0xff,0xff,0xfd,0xff,0xf0,0x03,0xff,0xf0,0x03,0xff,0xff,0xbc,
    0xff,0xff,0xff,0xf8,0xff,0xc0,0x07,0xff,0xfc,0x01,0xff,0xfe,0x7c,
    0xff,0xff,0xff,0xfe,0xfe,0x00,0x07,0xff,0xff,0x00,0x00,0x01,0xfc,
    0xff,0xff,0xff,0xfe,0xf8,0x00,0x0f,0xff,0xff,0x80,0x00,0x03,0xfc,
    0xff,0xff,0xff,0xfe,0xf0,0x00,0x0f,0xff,0xff,0x80,0x00,0x01,0xfc,
    0xff,0xff,0xff,0xfe,0xe0,0x00,0x1f,0xff,0xff,0x80,0x00,0x01,0xfc,
    0xff,0xff,0xff,0xfe,0xe0,0x00,0x1f,0xff,0xff,0x80,0x00,0x01,0xfc,
    0xff,0xff,0xff,0xfc,0xc0,0x00,0x3f,0xff,0xff,0xc0,0x00,0x01,0xfc,
    0xff,0xff,0xff,0xfc,0xc0,0xc0,0x3f,0xff,0xff,0xc0,0x00,0x01,0xfc,
    0xff,0xff,0xff,0xfc,0xc1,0xf0,0x7f,0xff,0xff,0xc0,0x1f,0x03,0xfc,
    0xff,0xff,0xff,0xfc,0xc0,0x08,0x7f,0xff,0xff,0xe3,0xff,0x83,0xfc,
    0xff,0xff,0xff,0xfc,0xc0,0x04,0x7f,0xff,0xff,0xe7,0xff,0xc1,0xfc,
    0xff,0xff,0xff,0xfc,0xc0,0x06,0x3f,0xff,0xff,0xe7,0xff,0xe0,0xfc,
    0xff,0xff,0xff,0xfc,0xc0,0x06,0x3f,0xff,0xff,0xe7,0xff,0xf8,0xfc,
    0xff,0xff,0xff,0xfe,0x40,0x07,0x3f,0xff,0xff,0xe7,0xff,0xfc,0xfc,
    0xff,0xff,0xff,0xfe,0x00,0x0f,0x9f,0xff,0xff,0xe7,0xff,0xfc,0xfc,
    0xff,0xff,0xff,0xff,0x00,0x0f,0x9f,0xff,0xff,0xef,0xff,0xfd,0xfc,
    0xff,0xff,0xff,0xff,0xc0,0x01,0xcf,0xff,0xff,0xef,0xff,0xfd,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xf1,0xf8,0x7f,0xff,0xff,0xff,0xff,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0xf8,0x7f,0xff,0xff,0xf8,0xff,0x7f,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0xf0,0x3f,0xff,0xff,0xf8,0x7e,0x3f,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0x70,0x3f,0xff,0xff,0xf0,0x7c,0x3f,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0x70,0x3f,0xff,0xff,0xf0,0x38,0x1f,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0x70,0x3f,0xff,0xff,0xf0,0x38,0x1f,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0x70,0x38,0xff,0xff,0xf0,0x38,0x1f,0xfc,
    0xff,0xff,0xff,0xfc,0xe0,0x78,0x30,0x7f,0xff,0xf0,0x38,0x1f,0xfc,
    0xff,0xff,0xff,0xf8,0x70,0x78,0x30,0x7f,0xfe,0xf8,0x38,0x3f,0xfc,
    0xff,0xff,0xff,0xf8,0x30,0xfc,0x60,0x7f,0xfc,0x3c,0xfc,0x7d,0xfc,
    0xff,0xff,0xff,0xf0,0x1d,0xff,0xe0,0x7f,0xfc,0x1f,0xff,0xf9,0xfc,
    0xff,0xff,0xff,0xf8,0x1f,0x03,0xe0,0x7f,0xfc,0x1f,0xc7,0xf0,0xfc,
    0xff,0xff,0xff,0xf8,0x1e,0x01,0xe0,0xff,0xfc,0x1f,0x83,0xe0,0xfc,
    0xff,0xff,0xff,0xf8,0x1c,0x00,0xe0,0xff,0xfc,0x1f,0x01,0xe0,0xfc,
    0xff,0xff,0xff,0xfc,0x1c,0x00,0x71,0xff,0xfc,0x1f,0x01,0xe0,0xfc,
    0xff,0xff,0xff,0xfc,0x1c,0x00,0x7f,0xff,0xfe,0x3e,0x01,0xf1,0xfc,
    0xff,0xff,0xff,0xff,0x78,0x00,0x3f,0xff,0xff,0xfe,0x01,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xfc,0x00,0xff,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0x00,0x07,0xff,0xff,0xf8,0x00,0x7f,0xfc,
    0xff,0xff,0xff,0xff,0xc0,0x00,0x07,0xff,0xff,0xf0,0x00,0x7f,0xfc,
    0xff,0xff,0xff,0xff,0xc0,0x00,0x03,0xff,0xff,0xe0,0x00,0x1f,0xfc,
    0xff,0xff,0xff,0xff,0x80,0x00,0x07,0xff,0xff,0xc0,0x00,0x0f,0xfc,
    0xff,0xff,0xff,0xff,0xc0,0x00,0x07,0xff,0xff,0xc0,0x00,0x07,0xfc,
    0xff,0xff,0xff,0xff,0xc0,0x00,0x0f,0xff,0xff,0xc0,0x00,0x07,0xfc,
    0xff,0xff,0xff,0xff,0xe0,0x00,0x1f,0xff,0xff,0xe0,0x00,0x0f,0xfc,
    0xff,0xff,0xff,0xff,0xf0,0x38,0x7f,0xff,0xff,0xf0,0x7c,0x1f,0xfc,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc
}

uint8_t draw_state = 0;

void draw(void) {
  u8g2_prepare();
  switch(draw_state >> 3) {
    case 0: u8g2_box_title(draw_state&7); break;
    case 1: u8g2_box_frame(draw_state&7); break;
    case 2: u8g2_disc_circle(draw_state&7); break;
    case 3: u8g2_r_frame(draw_state&7); break;
    case 4: u8g2_string(draw_state&7); break;
    case 5: u8g2_line(draw_state&7); break;
    case 6: u8g2_triangle(draw_state&7); break;
    case 7: u8g2_ascii_1(); break;
    case 8: u8g2_ascii_2(); break;
    case 9: u8g2_extra_page(draw_state&7); break;
    case 10: u8g2_xor(draw_state&7); break;
    case 11: u8g2_bitmap_modes(0); break;
    case 12: u8g2_bitmap_modes(1); break;
    case 13: u8g2_bitmap_overlay(draw_state&7); break;
  }
}


void setup(void) {
  Serial.begin(9600);
  Serial.println("Start");
  
  pinMode(10, OUTPUT);
  pinMode(9, OUTPUT);
  digitalWrite(10, 0);
  digitalWrite(9, 0);		

  u8g2.begin();
  //u8g2.setFlipMode(0);
}

void loop(void) {
  // picture loop  
  u8g2.firstPage();  
  do {
    draw();
  } while( u8g2.nextPage() );
  
  // increase the state
  draw_state++;
  if ( draw_state >= 14*8 )
    draw_state = 0;

  // delay between each page
  delay(150);

}
*/